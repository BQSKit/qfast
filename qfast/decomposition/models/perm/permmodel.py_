"""
QFAST Permutation Model Module

This models a circuit as a sequence of fixed gates potentially led by
a generic gate. Generic gates multiplex gate placement, or location, by
multiplying by permutation matrices.
"""


import logging

import numpy     as np
import functools as ft

from qfast import utils
from qfast import gate
from qfast.decomposition.circuitmodel import CircuitModel
from qfast.decomposition.models.perm.genericgate import GenericGate
from qfast.decomposition.models.perm.fixedgate import FixedGate


logger = logging.getLogger( "qfast" )


class PermModel ( CircuitModel ):

    def __init__ ( self, utry, gate_size, locations, optimizer,
                   success_threshold = 1e-3, progress_threshold = 5e-3,
                   structure = None, repeat_structure = False,
                   single_cycle = False ):
        """
        Permutation Model Constructor

        Args:
            utry (np.ndarray): The unitary to model.

            gate_size (int): The size of the model's gate.

            locations (list[tuple[int]): The valid locations for gates.

            optimizer (Optimizer): The optimizer available for use.

            success_threshold (float): The distance criteria for success.

            progress_threshold (float): The distance increase criteria
                for successful expansion.

            structure (list[tuple[int]]): The initial structure of the
                model.

            repeat_structure (bool): If true, expand by repeating the
                initial structure.

            single_cycle (bool): If true, terminate after a single
                optimizer cycle.
        """

        super().__init__( utry, gate_size, locations, optimizer )

        self.success_threshold = success_threshold
        self.progress_threshold = progress_threshold
        self.repeat_structure = repeat_structure
        self.single_cycle = single_cycle

        # Build initial model
        self.structure = structure
        self.head = GenericGate( self.num_qubits, self.gate_size, self.locations )
        self.gates = []
        self.param_ranges = [ 0 ]
        
        if self.structure is not None: 
            for location in structure:
                gate = FixedGate( self.num_qubits, self.gate_size, location )
                self.append_gate( gate )
        else:
            self.append_gate( self.head )

        self.x = self.get_initial_input()
        self.last_dist = 1


    def get_initial_input ( self ):
        """Get initial input of model."""
        return np.concatenate( [ gate.get_initial_input()
                                 for gate in self.gates ] )

    def append_gate ( self, gate ):
        """Append a gate onto the model."""
        self.gates.append( gate )
        self.param_ranges.append( self.param_ranges[-1]
                                  + gate.get_param_count() )
        self.x = np.concatenate( ( self.x, gate.get_initial_input() ) )

    def insert_gate ( self, gate, idx ):
        """Insert a gate into the model."""
        self.gates.insert( idx, new_gate )

        idx = len( self.gates ) - idx if idx < 0 else idx
        self.x = np.concatenate( ( self.x[ : self.param_ranges[ idx ] ],
                                   gate.get_initial_input(),
                                   self.x[ self.param_ranges[ idx ] : ] ) )

        self.param_ranges = [ 0 ]
        for gate in self.gates:
            self.param_ranges.append( self.param_ranges[-1]
                                      + gate.get_param_count() )

    def pop_gate ( self ):
        """Removes last gate in model."""
        if len( self.gates ) > 0:
            self.gates.pop()
            self.x = self.x[ : param_ranges[-2] ]
            self.param_ranges.pop()

    def get_param_count ( self ):
        """Total number of parameters in model."""
        return self.param_ranges[-1]

    def get_depth ( self ):
        """Returns depth of model."""
        return len( self.gates )

    def head_attached ( self ):
        """Returns true if the generic gate head is attached."""
        return isinstance( self.gates[-1], GenericGate )

    def distance ( self ):
        """Calculates the model's distance to the target unitary."""
        M = self.get_matrix()
        num = np.abs( np.trace( self.utry_dag @ M ) )
        dem = M.shape[0]
        return 1 - ( num / dem )

    def success ( self ):
        """If the model has successfully modeled the target unitary."""
        if self.single_cycle:
            return True

        return self.distance() < self.success_threshold

    def progress ( self ):
        """If the model has made progress."""
        if not self.head_attached():
            return True

        return self.last_dist - self.distance() > self.progress_threshold

    def expand ( self ):
        """Expand the model by adding gates."""
        if self.repeat_structure and self.structure is not None:
            for location in structure:
                gate = FixedGate( self.num_qubits, self.gate_size, location )
                self.append_gate( gate )

        elif not self.head_attached():
            self.append_gate( self.head )

        else:
            location = self.head.get_location( self.x )
            new_gate = FixedGate( self.num_qubits, self.gate_size, location )
            self.insert_gate( -1, new_gate )

        if self.head_attached():
            self.head.lift_restrictions()
            self.head.restrict( self.gates[-2].get_location() )

    def get_input_slice ( self, gate_idx ):
        """Returns the inputs for a specific gate."""
        if gate_idx < 0:
            lower_bound = self.param_ranges[ gate_idx - 1 ]
            upper_bound = self.param_ranges[ gate_idx ]
        else:
            lower_bound = self.param_ranges[ gate_idx ]
            upper_bound = self.param_ranges[ gate_idx + 1 ]

        return self.x[ lower_bound : upper_bound ]

    def get_gate_list ( self ):
        """Converts model to list of qfast gate objects."""
        gate_list = []

        for i, gate in enumerate( self.gates ):
            M = gate.get_gate_matrix( self.get_input_slice( i ) )
            L = gate.get_location()
            gate_list.append( gate.Gate( M, L ) )

        return gate_list

    def finalize ( self ):
        """Finalize the circuit by replacing the head if necessary."""
        if head_attached():
            location = self.head.get_location( self.get_input_slice( -1 ) )
            xhead  = self.head.get_function_values( self.get_input_slice( -1 ) )
            self.pop()

            new_gate = FixedGate( self.num_qubits, self.gate_size, location )
            self.append( new_gate )
        
            self.x = self.x[ : self.param_ranges[-2] ]
            self.x = np.concatenate( ( self.x, xhead ) )
            self.x = self.optimizer.minimize_fine( self.objective_fn, self.x )

        return self.get_gate_list()

    def solve ( self ):
        """Solve the model for the target unitary."""
        failed_locs = []

        while True:

            self.x = self.optimizer.minimize_coarse( self.objective_fn, self.x )

            logger.info( "Finished optimizing depth %d at %e distance."
                         % ( depth, self.distance() ) )

            if self.success():
                logger.info( "Exploration finished: success" )
                return self.finalize()

            if self.progress():
                logger.info( "Progress has been made, depth increasing." )
                self.last_dist = self.distance()
                self.expand()

            elif self.head.cannot_restrict():
                logger.info( "Progress has not been made." )
                logger.info( "Cannot restrict further, depth increasing." )

                if len( failed_locs ) > 0:
                    failed_locs.sort( key = lambda x : x[1] )
                    chosen_location, last_dist = failed_locs[0]
                else:
                    last_dist = distance
                logger.info( f"Choosing minimum distance: {chosen_location} {last_dist}" )
                self.expand( chosen_location )
                depth += 1
                failed_locs = []

            else:
                logger.info( "Progress has not been made, restricting model." )
                failed_locs.append( ( chosen_location, distance ) )
                self.head.restrict( chosen_location )


    def get_matrix ( self, x ):
        if len( self.gates ) == 0:
            return np.identity( self.utry_dag.shape[0] )
        
        if len( self.gates ) == 1:
            return self.gates[0].get_matrix(x)

        matrices = []

        for i, gate in enumerate( self.gates ):
            lower_bound = self.param_ranges[ i ]
            upper_bound = self.param_ranges[ i + 1 ]
            matrices.append( gate.get_matrix( x[ lower_bound : upper_bound ] ) )

        return ft.reduce( np.matmul, reversed( matrices ) )

    def get_matrix_and_derivatives ( self, x ):
        if len( self.gates ) == 0:
            return np.identity( self.utry_dag.shape[0] ), np.array([])
        
        if len( self.gates ) == 1:
            return self.gates[0].get_matrix_and_derivatives(x)

        matrices = []
        derivatives = []

        for i, gate in enumerate( self.gates ):
            lower_bound = self.param_ranges[ i ]
            upper_bound = self.param_ranges[ i + 1 ]
            M, J = gate.get_matrix_and_derivatives( x[ lower_bound : upper_bound ] )
            matrices.append( M )
            derivatives.append( J )

        matrix = ft.reduce( np.matmul, reversed( matrices ) )
        jacs = []

        for i, dM in enumerate( derivatives ):

            if i + 1 < len( derivatives ):
                left = ft.reduce( np.matmul, reversed( matrices[i+1:] ) )
            else:
                left = np.identity( self.utry_dag.shape[0] )


            if i != 0:
                right = ft.reduce( np.matmul, reversed( matrices[:i] ) )
            else:
                right = np.identity( self.utry_dag.shape[0] )

            for dm in dM:
                jacs.append( left @ dm @ right )

        return matrix, np.array( jacs )

    def objective_fn ( self, x ):
        M, dM = self.get_matrix_and_derivatives( x )
        obj = -np.real( np.trace( self.utry_dag @ M ) )
        jacs = []
        for dm in dM:
            jacs.append( -np.real( np.trace( self.utry_dag @ dm ) ) )
        jacs = np.array( jacs )
        return obj, jacs

